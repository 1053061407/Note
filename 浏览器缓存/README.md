## 浏览器缓存概述
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：

1. 先根据这个资源的一些http header判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
2. 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
3. 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不对发送请求到服务器，但协商缓存会。
4. 当协商缓存也没命中时，服务器就会将资源发送回客户端。
## 缓存分类
### 1.强缓存
强缓存是指当浏览器第一次向服务器请求某个资源时，浏览器会把资源丢给浏览器，同时告诉浏览器应当把这个资源缓存起来，以便日后再次请求时，可以直接使用，不用再向服务器请求。浏览器接收到资源后，连同response header一起缓存下来。强缓存就是利用http的返回头部的中Expires（实体首部字段）或者Cache-Control（通用首部字段）两个字段来控制的。

强缓存有Expires和Cache-control两种方式
> `Expires字段`
Expires字段是服务器通过在响应头中指定资源的到期时间。浏览器第一次跟服务器请求一个资源时，服务器在返回这个资源时，在相应头部会加上Expires。下次请求时，浏览器对比该请求的时间和Expires的时间，如果该请求的时间 < Expires的时间,说明没有到期，则命中强缓存。如果该请求的时间 > Expires的时间,说明资源已经到期，应当重新请求。

缺点：服务器返回的Expires时间是服务器上的时间，可能与客户端有时间差，时间差太大时可能造成缓存混乱。
> `Cache-control:max-age`
Cache-control字段是指定该资源的有效期，是相对时间。
浏览器第一次跟服务器请求一个资源时，服务器在返回这个资源时，在相应头部会加上Cache-control：max-age=xxxxxxx。当下次请求时，浏览器会先从缓存中找到这个资源，获取date(第一次返回资源的响应时间)和max-age然后相加计算出一个有效期(date + max-age)，然后再和浏览器请求时间比较最后判断是否命中强缓存（逻辑同Expires）；

Cache-Control描述的是相对时间，采用本地时间来计算资源的有效期，所以相比Expires更可靠。

**这两个Header可以只用其一，也可以一起使用。一起使用时以Cache-Control为准。(因为Expires的时间是服务器的时间，如果与客户端有时间差，时间差太大时可能造成缓存混乱，所以以Cache-Control优先)**
### 2.协商缓存
当强缓存未命中时，浏览器就会发送请求到服务器，服务器会验证协商缓存是否命中，如果协商缓存命中，请求返回的http状态为304，并会显示说明Not Modified，浏览器收到该返回后，就会从缓存中加载了。
**协商缓存利用[Last-Modified , If-Modified-Since] 和 [ETag , If-None-Match]这两对Header来管理。**
#### Last-Modified & If-Modified-Since
Last-Modified为实体首部字段，值为资源最后更新时间，随服务器response返回

If-Modified-Since为请求首部字段，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的Last-Modified时间。其过程如下：
1. 浏览器第一次请求资源时，服务器返回了该资源，同时会在response headers中加上Last-Modified，这个header表示这个资源在服务器上的最后一次修改时间；
2. 当浏览器下次请求时，请求头会加上If-Modified-Since，这个header的值等于上一次请求时服务器返回的Last-Modified的值。
3. 服务器将浏览器请求头部的If-Modified-Since的值与资源在服务器上的最后修改时间与对比，如果If-Modifid-Since与最后修改时间一致，则命中缓存，服务器返回304，浏览器从缓存中获取资源；若未命中缓存，服务器返回资源同时，浏览器缓存资源的Last-Modified会被更新。

#### ETag & If-None-Match
有些情况下仅判断最后修改日期来验证资源是否有改动是不够的：
1. 一个资源被修改了，但其实际内容根本没发生改变，会导致Last-Modified时间匹配不上
2. 被修改的信息并不重要，如注释等；
3. Last-Modified无法精确到毫秒，但有些资源更新频率有时会小于一秒。

为解决这些问题，**服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在response实体首部加上“ETag: 唯一标识符”一起返回给客户端。**

If-None-Match为请求头部字段，服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的ETag。其过程如下：

1. 服务器第一次收到浏览器发出的资源请求时，会在response headers中加上ETag，这个ETag是根据该资源生成的唯一标识，这个唯一标识是个字符串，只要服务器认为资源有变化且应该提供新的资源，则ETag就必须有变化。浏览器将资源连同ETag一并缓存。
2. 当浏览器再一次向服务器发送该资源的请求时，会在request headers中加上If-None-Match，该值即为第一次服务器返回的ETag值；
3. 服务器收到资源请求后，会根据要请求的资源重新计算生成相应的ETag，然后与If-None-Match比较。对比结果一致即命中缓存，不一致则未命中缓存，返回资源同时将新的ETag发送至浏览器。

参考文章:
[HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)
 [浏览器缓存知识小结及应用](http://www.cnblogs.com/lyzg/p/5125934.html)
[浏览器缓存](https://segmentfault.com/a/1190000006672573)
